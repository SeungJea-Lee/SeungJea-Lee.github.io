---
layout: single
title:  "가상 함수와 추상 클래스 - 2"
categories: code
tag: [c++, blog, jekyll]
author_profile: false
sidebar: 
    nav: "counts"
redirect_from:
    - /coding/first
use_math: false
---

**[안내]** 공부 기록용 블로그이다 보니 틀린 점이 있을 수 있습니다. 혹시 틀린 부분이 있으면 댓글로 알려주시면 감사하겠습니다!
{: .notice--info}

# [c++] 동적 바인딩이 발생하는 구체적인 경우

```c++
#include <iostream>
using namespace std;
class Shape {
public:
    void paint() { // 1번
    draw(); 
}
    virtual void draw() { 
    	cout << "Shape::draw() called" << endl; 
} };
class Circle : public Shape {
public:
    void draw() override { 
    	cout << "Circle::draw() called" << endl;
}
    void repaint() { // 2번
    	draw();
} };
class Manager {
public:
    void display(Shape *p) { 
    	p->draw(); // 3번
} };
int main() {
    Shape *pShape = new Circle(); // 업캐스팅
    pShape->draw(); // ③
    pShape->paint(); // ①
    Manager m;
    m.diplay(pShape); // ④
    ((Circle *)pShape)->repaint(); // ②
    delete pShape; 
}
```

동적 바인딩이란 호출 될 함수가 실행시간에 결정되는 것을 말한다. 

동적 바인딩이 발생하는 구체적인 경우는 크게 4가지가 있다. 

1번: 기본 클래스 내의 멤버 함수가 가상 함수 호출할 때 - 기본 클래스 내의 멤버 함수가 가상 함수를 호출하면 기본 클래스를 상속 받은 클래스에서 오버라이된 함수가 호출이 되는데 이때 이 함수가 실행되는 것은 실행시간에 결정되는 것으로 동적 바인딩에 해당한다.

2번: 파생 클래스 내의 멤버 함수가 가상 함수 호출할 때 - 파생 클래스 내의 멤버 함수가 가상 함수를 호출하면 그 가상 함수는 파생 클래스의 오버라이딩된 함수를 호출하고 사실상 자기자신의 함수를 부르는 것이다. 

3번: main()과 같은 외부 함수에서 기본 클래스의 포인터로 가상 함수 호출할 때 - 외부 함수에서 기본 클래스의 포인터로 가상 함수를 호출하면 기본 클래스의 가상 함수가 실행이 되고 가상 함수에서 파생 클래스의 오버라이딩된 함수로 토스를 해서 오버라이딩된 함수가 실행이 된다. 

4번: 다른 클래스에서 기본 클래스의 포인터로 가상 함수 호출할 때도 마찬가지로 오버라이딩된 함수가 실행이 된다. 

# override 키워드의 사용 이점

override를 처음 설명할때도 말했지만 override를 써도 되고 안 써도 상관이 없다. 하지만 가능하면 쓰는 것이 좋다고 생각한다. 만약 override된 함수를 작성하면서 함수의 이름을 잘 못 쓴 경우 override를 써주면 개발자는 작성 실수를 금방 파악 가능하지만 override를 써주지 않으면 오류를 찾는데 시간이 걸릴 수고 다른 사람이 내가 쓴 코드를 읽을 때도 override를 써주면 가독성도 좋고 이해하기도 좋으니 가능하면 쓰는 것이 좋다고 생각한다. 

# final 키워드: 오버라이딩 금지 또는 상속 금지

가상 함수를 선언하고 다른 클래스에서 상속 받아 오버라이딩하고 또 다른 클래스에서 오버라이딩하고 이 처럼 계속 오버라이딩하는 것이 가능하다, 하지만 함수이름 override 뒤에 final을 써주면 추후 이 클래스를 상속 받아 오버라이딩하는 것을 막아준다. 

또 final은 함수뿐만 아니라 클래스에도 사용이 가능하다. 클래스를 선언 할 때 함수때와 마찬가지로 클래스 이름 뒤에 final을 써주면 추후 해당 클래스의 상속을 막아준다. 

마지막으로 상수 변수를 만들때 사용이 가능하다. 변수 선언 앞에 final을 붙여주면 된다. 예를 들어 final int a = 3; 이렇게 선언을 해주면 a에는 3이 들어가고 그리고  a에 값을 집어넣을 수 없게된다. 

# c++ 오버라이딩의 특징

오버라이딩이 성공하려면 가상 함수 이름, 매개 변수 타입과 개수, 리턴 타입이 오버라이딩하려는 함수와 모두 일치해야 한다. 

# 상속이 반복되는 경우 가상 함수 호출

```c++
class Base {
public: 
    virtual void f() { cout << "Base::f() called" << endl; }
};
class Derived : public Base {
public: 
    void f() override { cout << "Derived::f() called" << endl; }
};
class GrandDerived : public Derived {
public: 
    void f() override { cout << "GrandDerived::f() called" << endl; }
};
int main() {
    GrandDerived g;
    Base *bp;
    Derived *dp;
    GrandDerived *gp;
    bp = dp = gp = &g; // 업캐스팅
    bp->f();
    dp->f();
    gp->f();
}
```

GrandDerived 객체는 Derived를 상속받은 클래스이고 Derived 클래스는 Base를 상속받은 클래스이다. 그리고 Base의 f() 함수를 Derived에서 오버라이딩하고 GrandDerived에서 또 오버라이딩되었다. 

bp, dp, gp 모두 g 객체의 주소를 나타내고 있다. bp->f(); 이 코드가 실행이 되면 기본 클래스의 함수가 실행이 되는데 이 함수는 Derived 클래스에서 오버라이딩되어있고 또 Derived 클래스를 상속받은 GrandDerived 클래스에서 함수를 오버라이딩하고 있어서 결국 GrandDerived 클래스의 오버라이딩된 함수가 실행이된다. 즉 bp->f(); 이 코드가 실행이 되면 바로 GrandDerived 클래스의 오버라이딩된 함수가 실행이 된다.  dp->f(); 이 코드가 실행됐을 때도 마찬가지로 GrandDerived 클래스의 오버라이딩된 함수가 실행이 되고, 마지막으로 gp->f(); 이 코드가 실행이 되도 자기 자신의 함수가 실행이 된다. 결론은 상속을 여러번을 하고 오버라이딩을 여러번 해도 상관없이 마지막으로 오버라이딩된 함수가 실행이 된다는 것이다. 

다만, 기본 클래스를 여러번 상속을 받더라도 기본 클래스의 함수가 가상함수가 아니라면 마지막으로 상속받은 클래스의 함수가 실행이 되는 것이 아니라 호출한 객체 포인터가 가르키는 객체에서 선언 된 함수가 실행이 된다. 

# 오버라이딩과 범위 지정 연산자(::)

```c++
class Shape {
public:
virtual void draw() { 
    cout << "Shape::draw() called" << endl; 
    }
};
class Circle : public Shape {
public:
    void draw() override { 
        Shape::draw(); // 기본 클래스의 draw()를 실행한다.
        cout << " Circle ::draw() called" << endl; 
    }
};

int main() {
    Circle c, *cp = &c;
    cp->draw(); // Circle의 draw() 호출
    cp->Shape::draw(); // Shape의 draw() 호출
    
    Shape *sp = cp; // Up casting
    sp->draw(); // Circle의 draw() 호출
    sp->Shape::draw(); // Shape의 draw() 호출
}
```



cp->draw() 이 코드를 실행해주면 오버라이딩된 함수가 실행이 되는데, 오버라이딩된 함수가 아닌 shape 클래스에서 정의된 기본 함수를 싶을 때는 코드를 		cp->Shape::draw(); 이렇게 바꿔주면 기본 함수가 실행이 된다. c객체에는 draw() 함수가 2개가 있는데 하나는 기본 함수이고 하나는 오버라이딩한 함수이다. 그런데 cp->Shape::draw(); 이 코드와 같이 클래스 이름을 직접 지정해주고 draw() 함수를 호출하면 기본 클래스에 있는 함수가 실행이 된다. 

sp는 cp와 마찬가지로 객체 c의 주소값을 가지고 있다. 그리고 sp->draw(); 이 코드가 실행이 되면 기본 클래스에 있는건 가상 함수이기 때문에 상속 받은 클래스에서 오버라이딩된 함수가 실행이 된다. 그리고 위에서 설명한 것과 마찬가지로 sp->Shape::draw(); 이 코드가 실행이 되면 기본 클래스의 함수가 바로 실행이 된다. sp->Shape::draw();, cp->Shape::draw(); 이 코드 같은 경우는 컴파일 할 때 실행될 함수가 결정이 되기 때문에 정적 바인딩이다. 

sp->draw(); 이 코드가 실행이 되면 컴파일러는 기본 클래스의 함수가 실행이 될지 아니면 상속 받은 클래스의 함수가 실행이 될지 모른다. sp->draw(); 이 코드는 단순히 기본 클래스의 함수의 정보를 참고해서 해당 함수를 호출해라라고만 되어있다. 컴파일러가 함수가 가상 함수라면 함수가 있는 곳에 함수가 아니라 별도의 공간을 포인터 변수를 하나 더 만들어 놓는다. 그래서 sp->draw(); 이렇게 함수를 호출하면 만들었던 공간에 저장이 되어있는 상속 받은 함수의 주소값이 들어가있도록 컴파일러가 구현을 한다. 함수의 주소값이라는 것은 함수 안에 있는 첫 번째 명령어의 주소이다. 즉 그 함수로 가야될 첫 번째 명령어의 주소가 별도의 포인터 변수가 만들어져서 거기에 주소값이 저장되는 것이다. 그래서 sp->draw(); 이런 식으로 draw() 함수를 호출하면 기본 클래스의 draw() 함수가 직접 실행이 되는 것이 아니라 draw() 함수 옆에 포인터 변수가 하나 있고, 그 포인터 변수를 참고해서 거기 있는 주소값으로 점프해가고 그 점프해서 간 곳이 상속 받은 클래스의 함수인 것이다. 그리고 그 함수로 점프해서 가는 것을 프로그램이 실행할 때 최종적으로 점프해서 가는거니까 컴파일할때는 그 저장된 주소로 점프하라고만 결정이 되고 실질적으로 어떤 함수가 실행되는지는 모른다. 그리고 이전 포스트에서 말했듯이 이게 동적 바인딩이다.

# 가상 소멸자

생성자는 여러개 만들 수 있는데 소멸자는 하나밖에 만들지 못 한다. 그런데 생성자는 가상 생성자라는 것은 없다. 그러나 소멸자의 경우 가상 소멸자가 필요한 경우가 있다. 일반적으로 소멸자는 굳이 만들어줄 필요가 없지만 만약 클래스에서 메모리를 동적을 할당을 한 경우는 반드시 소멸자에서 메모리를 반납을 해줘야 하고 이런 경우는 소멸자가 필요하다. 또 파일은 열거나 서버를 연결한 경우에도 소멸자가 필요하다. 

기본 클래스에 소멸자가 있고 기본 클래스를 상속 받은 클래스에도 소멸자가 있고, 상속 받은 클래스에 메모리 할당을 해주고 그 주소값을 기본 클래스 포인터에 저장을 했다고 생각을 해보자. 그리고 메모리를 해제할 때 delete 기본 클래스 포인터; 이런 식으로 해제를 하면 기본 클래스에 대한 포인터 이기때문에 기본 클래스의 소멸자만 실행이 되고 상속 받은 클래스의 소멸자는 실행이 안 된다. 이런 문제가 있기 때문에 소멸자 앞에 virtual을 써준다. 그리고 가상 함수때와 마찬가지로 상속 받은 클래스의 소멸자 뒤에 override를 써준다. 가상 함수때는 함수의 이름이 같았지만 가상 소멸자는 소멸자의 이름이 다르다.  delete 기본 클래스 포인터;를 해주면 기본 클래스의 가상 소멸자가 실행이 되고 그리고 상속 받은 클래스의 소멸자로 점프해간다. 그래서 상속 받은 클래스의 소멸자가 실행이 되고 실행 후 기본 클래스의 소멸자가 자동으로 호출이 되서 실행이 된다. delete 상속 받은 클래스 포인터;로 해도 상속 받은 클래스 소멸자가 실행이 되고 그 후 기본 클래스의 소멸자가 자동으로 실행이 된다. 
