---
layout: single
title:  "가상 함수와 추상 클래스 - 2"
categories: code
tag: [c++, blog, jekyll]
author_profile: false
sidebar: 
    nav: "counts"
redirect_from:
    - /coding/first
use_math: false
---

**[안내]** 공부 기록용 블로그이다 보니 틀린 점이 있을 수 있습니다. 혹시 틀린 부분이 있으면 댓글로 알려주시면 감사하겠습니다!
{: .notice--info}

# [c++] 동적 바인딩이 발생하는 구체적인 경우

```c++
#include <iostream>
using namespace std;
class Shape {
public:
    void paint() { // 1번
    draw(); 
}
    virtual void draw() { 
    	cout << "Shape::draw() called" << endl; 
} };
class Circle : public Shape {
public:
    void draw() override { 
    	cout << "Circle::draw() called" << endl;
}
    void repaint() { // 2번
    	draw();
} };
class Manager {
public:
    void display(Shape *p) { 
    	p->draw(); // 3번
} };
int main() {
    Shape *pShape = new Circle(); // 업캐스팅
    pShape->draw(); // ③
    pShape->paint(); // ①
    Manager m;
    m.diplay(pShape); // ④
    ((Circle *)pShape)->repaint(); // ②
    delete pShape; 
}
```

동적 바인딩이란 호출 될 함수가 실행시간에 결정되는 것을 말한다. 

동적 바인딩이 발생하는 구체적인 경우는 크게 4가지가 있다. 

1번: 기본 클래스 내의 멤버 함수가 가상 함수 호출할 때 - 기본 클래스 내의 멤버 함수가 가상 함수를 호출하면 기본 클래스를 상속 받은 클래스에서 오버라이된 함수가 호출이 되는데 이때 이 함수가 실행되는 것은 실행시간에 결정되는 것으로 동적 바인딩에 해당한다.

2번: 파생 클래스 내의 멤버 함수가 가상 함수 호출할 때 - 파생 클래스 내의 멤버 함수가 가상 함수를 호출하면 그 가상 함수는 파생 클래스의 오버라이딩된 함수를 호출하고 사실상 자기자신의 함수를 부르는 것이다. 

3번: main()과 같은 외부 함수에서 기본 클래스의 포인터로 가상 함수 호출할 때 - 외부 함수에서 기본 클래스의 포인터로 가상 함수를 호출하면 기본 클래스의 가상 함수가 실행이 되고 가상 함수에서 파생 클래스의 오버라이딩된 함수로 토스를 해서 오버라이딩된 함수가 실행이 된다. 

4번: 다른 클래스에서 기본 클래스의 포인터로 가상 함수 호출할 때도 마찬가지로 오버라이딩된 함수가 실행이 된다. 

# override 키워드의 사용 이점

override를 처음 설명할때도 말했지만 override를 써도 되고 안 써도 상관이 없다. 하지만 가능하면 쓰는 것이 좋다고 생각한다. 만약 override된 함수를 작성하면서 함수의 이름을 잘 못 쓴 경우 override를 써주면 개발자는 작성 실수를 금방 파악 가능하지만 override를 써주지 않으면 오류를 찾는데 시간이 걸릴 수고 다른 사람이 내가 쓴 코드를 읽을 때도 override를 써주면 가독성도 좋고 이해하기도 좋으니 가능하면 쓰는 것이 좋다고 생각한다. 

# final 키워드: 오버라이딩 금지 또는 상속 금지

가상 함수를 선언하고 다른 클래스에서 상속 받아 오버라이딩하고 또 다른 클래스에서 오버라이딩하고 이 처럼 계속 오버라이딩하는 것이 가능하다, 하지만 함수이름 override 뒤에 final을 써주면 추후 이 클래스를 상속 받아 오버라이딩하는 것을 막아준다. 

또 final은 함수뿐만 아니라 클래스에도 사용이 가능하다. 클래스를 선언 할 때 함수때와 마찬가지로 클래스 이름 뒤에 final을 써주면 추후 해당 클래스의 상속을 막아준다. 

마지막으로 상수 변수를 만들때 사용이 가능하다. 변수 선언 앞에 final을 붙여주면 된다. 예를 들어 final int a = 3; 이렇게 선언을 해주면 a에는 3이 들어가고 그리고  a에 값을 집어넣을 수 없게된다. 

# c++ 오버라이딩의 특징

오버라이딩이 성공하려면 가상 함수 이름, 매개 변수 타입과 개수, 리턴 타입이 오버라이딩하려는 함수와 모두 일치해야 한다. 

# 상속이 반복되는 경우 가상 함수 호출

```c++
class Base {
public: 
    virtual void f() { cout << "Base::f() called" << endl; }
};
class Derived : public Base {
public: 
    void f() override { cout << "Derived::f() called" << endl; }
};
class GrandDerived : public Derived {
public: 
    void f() override { cout << "GrandDerived::f() called" << endl; }
};
int main() {
    GrandDerived g;
    Base *bp;
    Derived *dp;
    GrandDerived *gp;
    bp = dp = gp = &g; // 업캐스팅
    bp->f();
    dp->f();
    gp->f();
}
```

GrandDerived 객체는 Derived를 상속받은 클래스이고 Derived 클래스는 Base를 상속받은 클래스이다. 그리고 Base의 f() 함수를 Derived에서 오버라이딩하고 GrandDerived에서 또 오버라이딩되었다. 

bp, dp, gp 모두 g 객체의 주소를 나타내고 있다. bp->f(); 이 코드가 실행이 되면 기본 클래스의 함수가 실행이 되는데 이 함수는 Derived 클래스에서 오버라이딩되어있고 또 Derived 클래스를 상속받은 GrandDerived 클래스에서 함수를 오버라이딩하고 있어서 결국 GrandDerived 클래스의 오버라이딩된 함수가 실행이된다. 즉 bp->f(); 이 코드가 실행이 되면 바로 GrandDerived 클래스의 오버라이딩된 함수가 실행이 된다.  dp->f(); 이 코드가 실행됐을 때도 마찬가지로 GrandDerived 클래스의 오버라이딩된 함수가 실행이 되고, 마지막으로 gp->f(); 이 코드가 실행이 되도 자기 자신의 함수가 실행이 된다. 결론은 상속을 여러번을 하고 오버라이딩을 여러번 해도 상관없이 마지막으로 오버라이딩된 함수가 실행이 된다는 것이다. 

다만, 기본 클래스를 여러번 상속을 받더라도 기본 클래스의 함수가 가상함수가 아니라면 마지막으로 상속받은 클래스의 함수가 실행이 되는 것이 아니라 호출한 객체 포인터가 가르키는 객체에서 선언 된 함수가 실행이 된다. 
