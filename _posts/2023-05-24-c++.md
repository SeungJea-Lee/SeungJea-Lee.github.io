---
layout: single
title:  "가상 함수와 추상 클래스 - 2"
categories: code
tag: [c++, blog, jekyll]
author_profile: false
sidebar: 
    nav: "counts"
redirect_from:
    - /coding/first
use_math: false
---

**[안내]** 공부 기록용 블로그이다 보니 틀린 점이 있을 수 있습니다. 혹시 틀린 부분이 있으면 댓글로 알려주시면 감사하겠습니다!
{: .notice--info}

# 오버라이딩과 범위 지정 연산자(::)

```c++
class Shape {
public:
virtual void draw() { 
    cout << "Shape::draw() called" << endl; 
    }
};
class Circle : public Shape {
public:
    void draw() override { 
        Shape::draw(); // 기본 클래스의 draw()를 실행한다.
        cout << " Circle ::draw() called" << endl; 
    }
};

int main() {
    Circle c, *cp = &c;
    cp->draw(); // Circle의 draw() 호출
    cp->Shape::draw(); // Shape의 draw() 호출
    
    Shape *sp = cp; // Up casting
    sp->draw(); // Circle의 draw() 호출
    sp->Shape::draw(); // Shape의 draw() 호출
}
```



cp->draw() 이 코드를 실행해주면 오버라이딩된 함수가 실행이 되는데, 오버라이딩된 함수가 아닌 shape 클래스에서 정의된 기본 함수를 싶을 때는 코드를 		cp->Shape::draw(); 이렇게 바꿔주면 기본 함수가 실행이 된다. c객체에는 draw() 함수가 2개가 있는데 하나는 기본 함수이고 하나는 오버라이딩한 함수이다. 그런데 cp->Shape::draw(); 이 코드와 같이 클래스 이름을 직접 지정해주고 draw() 함수를 호출하면 기본 클래스에 있는 함수가 실행이 된다. 

sp는 cp와 마찬가지로 객체 c의 주소값을 가지고 있다. 그리고 sp->draw(); 이 코드가 실행이 되면 기본 클래스에 있는건 가상 함수이기 때문에 상속 받은 클래스에서 오버라이딩된 함수가 실행이 된다. 그리고 위에서 설명한 것과 마찬가지로 sp->Shape::draw(); 이 코드가 실행이 되면 기본 클래스의 함수가 바로 실행이 된다. sp->Shape::draw();, cp->Shape::draw(); 이 코드 같은 경우는 컴파일 할 때 실행될 함수가 결정이 되기 때문에 정적 바인딩이다. 

sp->draw(); 이 코드가 실행이 되면 컴파일러는 기본 클래스의 함수가 실행이 될지 아니면 상속 받은 클래스의 함수가 실행이 될지 모른다. sp->draw(); 이 코드는 단순히 기본 클래스의 함수의 정보를 참고해서 해당 함수를 호출해라라고만 되어있다. 컴파일러가 함수가 가상 함수라면 함수가 있는 곳에 함수가 아니라 별도의 공간을 포인터 변수를 하나 더 만들어 놓는다. 그래서 sp->draw(); 이렇게 함수를 호출하면 만들었던 공간에 저장이 되어있는 상속 받은 함수의 주소값이 들어가있도록 컴파일러가 구현을 한다. 함수의 주소값이라는 것은 함수 안에 있는 첫 번째 명령어의 주소이다. 즉 그 함수로 가야될 첫 번째 명령어의 주소가 별도의 포인터 변수가 만들어져서 거기에 주소값이 저장되는 것이다. 그래서 sp->draw(); 이런 식으로 draw() 함수를 호출하면 기본 클래스의 draw() 함수가 직접 실행이 되는 것이 아니라 draw() 함수 옆에 포인터 변수가 하나 있고, 그 포인터 변수를 참고해서 거기 있는 주소값으로 점프해가고 그 점프해서 간 곳이 상속 받은 클래스의 함수인 것이다. 그리고 그 함수로 점프해서 가는 것을 프로그램이 실행할 때 최종적으로 점프해서 가는거니까 컴파일할때는 그 저장된 주소로 점프하라고만 결정이 되고 실질적으로 어떤 함수가 실행되는지는 모른다. 그리고 이전 포스트에서 말했듯이 이게 동적 바인딩이다.

# 가상 소멸자

생성자는 여러개 만들 수 있는데 소멸자는 하나밖에 만들지 못 한다. 그런데 생성자는 가상 생성자라는 것은 없다. 그러나 소멸자의 경우 가상 소멸자가 필요한 경우가 있다. 일반적으로 소멸자는 굳이 만들어줄 필요가 없지만 만약 클래스에서 메모리를 동적을 할당을 한 경우는 반드시 소멸자에서 메모리를 반납을 해줘야 하고 이런 경우는 소멸자가 필요하다. 또 파일은 열거나 서버를 연결한 경우에도 소멸자가 필요하다. 

기본 클래스에 소멸자가 있고 기본 클래스를 상속 받은 클래스에도 소멸자가 있고, 상속 받은 클래스에 메모리 할당을 해주고 그 주소값을 기본 클래스 포인터에 저장을 했다고 생각을 해보자. 그리고 메모리를 해제할 때 delete 기본 클래스 포인터; 이런 식으로 해제를 하면 기본 클래스에 대한 포인터 이기때문에 기본 클래스의 소멸자만 실행이 되고 상속 받은 클래스의 소멸자는 실행이 안 된다. 이런 문제가 있기 때문에 소멸자 앞에 virtual을 써준다. 그리고 가상 함수때와 마찬가지로 상속 받은 클래스의 소멸자 뒤에 override를 써준다. 가상 함수때는 함수의 이름이 같았지만 가상 소멸자는 소멸자의 이름이 다르다.  delete 기본 클래스 포인터;를 해주면 기본 클래스의 가상 소멸자가 실행이 되고 그리고 상속 받은 클래스의 소멸자로 점프해간다. 그래서 상속 받은 클래스의 소멸자가 실행이 되고 실행 후 기본 클래스의 소멸자가 자동으로 호출이 되서 실행이 된다. delete 상속 받은 클래스 포인터;로 해도 상속 받은 클래스 소멸자가 실행이 되고 그 후 기본 클래스의 소멸자가 자동으로 실행이 된다. 